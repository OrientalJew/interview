#### Solid原则

solid指：single，open-close，Lisk，interface，depend；

single：单一职责原则，一个函数或类，应该遵循其名称定义来划分其职责，不应该赋予其超过职责的功能；

> 典型的场景就是Model类型，让数据与业务隔离；Model只做数据的存取；操作数据的业务逻辑交给其他类去进行；
>
> 优点：降低类的负责度，提高了系统的可维护性，变更代码的风险大大降低；
>
> 缺点：增加了代码量，提高了冗余度；

open-close：开闭原则，软件实体\(类，模块，方法等\)应该对扩展开放，对修改关闭；

> 适当的封装和抽象能够帮助我们更好的遵循开闭原则；对于事物的共性，抽象出一个操作共性接口来，当需要扩展该事物的子功能时，只需要实现该共性接口，编写对应类型的功能即可完成扩展。不需要对源代码进行任何修改即可完成扩展。

Lisk：里斯替换原则，子类或实现类继承了父类的所有特性，在进行参数传递时，子类可以显式的替代父类，作为参数传递给函数；同样，在进行赋值操作时，子类实例也可以直接赋值给父类实例；反过来则不行。

> 我们可以用类或接口的任何扩展\(实现类\)来替换它，程序的行为不会受到破坏。

interface：接口隔离原则，定义接口时，应该尽可能的做到功能的单一性，不同功能应该放到不同的接口中；同时使用多个专门的接口要比使用单一的接口更好。

dependence：依赖倒置原则，高层模块与底层模块不应该互相依赖，两者都应该依赖于抽象。

> 底层模块抽象出通用的数据操作接口交给高层模块，高层模块只知道根据这些接口操作实现业务逻辑，并不了解实际的数据操作细节，对于高层模块来说，也没有必要知道这些操作细节。

#### 简单工厂模式

将产品的实现细节封装在对应的工厂中，用户并不需要知道产品的实现细节，只需要知道根据不同的条件，调用不同的工厂，生产对应的产品。

#### 策略模式

某一个功能的实现，可以根据不同的需求，使用不同的实现方式，每一种方式都可以单独封装起来，形成单独的策略。

> 比如动画的插值器，同样结果的动画，通过使用不同的插值器，能够实现不同的动画效果。

#### 代理模式

对于一套接口规范，代理对象和被代理对象都实现了这套规范。使用时，我们操作代理对象实现功能，但实际上，代理对象只是一个空壳，功能的实现实际是由被代理对象完成的。并且，我们可以根据不同的业务场景，为代理对象赋予不同的被代理对象实例。在调用者看来，代理对象对外表现是一致不变的。

> Android 的ViewCompat、MenuItemCompat等兼容类，其中实现了多个系统版本被代理对象，我们使用时只需要调用功能实现细节即可，而兼容类会自动根据我们系统版本，调用不同的版本对应的实现方法。
>
> 另一个使用场景就是缓存切换，我们抽象出通用的存取方法，而实际的缓存介质，我们可以根据需求进行切换。





























