#### Solid原则

solid指：single，open-close，Lisk，interface，depend；

single：单一职责原则，一个函数或类，应该遵循其名称定义来划分其职责，不应该赋予其超过职责的功能；

> 典型的场景就是Model类型，让数据与业务隔离；Model只做数据的存取；操作数据的业务逻辑交给其他类去进行；
>
> 优点：降低类的复杂度，提高了系统的可维护性，变更代码的风险大大降低；
>
> 缺点：增加了代码量，提高了冗余度；

open-close：开闭原则，软件实体\(类，模块，方法等\)应该对扩展开放，对修改关闭；

> 适当的封装和抽象能够帮助我们更好的遵循开闭原则；对于事物的共性，抽象出一个操作共性接口来，当需要扩展该事物的子功能时，只需要实现该共性接口，编写对应类型的功能即可完成扩展。以对源代码进行最小的修改即可完成扩展。

Lisk：里斯替换原则，子类或实现类继承了父类的所有特性，在进行参数传递时，子类可以显式的替代父类，作为参数传递给函数；同样，在进行赋值操作时，子类实例也可以直接赋值给父类实例；反过来则不行。

> 我们可以用类或接口的任何扩展\(实现类\)来替换它，程序的行为不会受到破坏。

interface：接口隔离原则，定义接口时，应该尽可能的做到功能的单一性，不同功能应该放到不同的接口中；同时使用多个专门的接口要比使用单一的接口更好。

dependence：依赖倒置原则，高层模块与底层模块不应该互相依赖，两者都应该依赖于抽象。

> 底层模块抽象出通用的数据操作接口交给高层模块，高层模块只知道根据这些接口操作实现业务逻辑，并不了解实际的数据操作细节，对于高层模块来说，也没有必要知道这些操作细节。
>
> 通过抽象封装，让各层依赖抽象，减少各层之间的耦合。

#### 简单工厂模式

将产品的实现细节封装在对应的工厂中，用户并不需要知道产品的实现细节，只需要知道根据不同的条件，调用不同的工厂，生产对应的产品。\(ThreadFactory\)

#### 策略模式

某一个功能的实现，可以根据不同的需求，使用不同的实现方式，每一种方式都可以单独封装起来，形成单独的策略。

> 比如动画的插值器，同样结果的动画，通过使用不同的插值器，能够实现不同的动画效果。

#### 代理模式

对于一套接口规范，代理对象和被代理对象都实现了这套规范。使用时，我们操作代理对象实现功能，但实际上，代理对象只是一个空壳，功能的实现实际是由被代理对象完成的。并且，我们可以根据不同的业务场景，为代理对象赋予不同的被代理对象实例。在调用者看来，代理对象对外表现是一致不变的。

> Android 的ViewCompat、MenuItemCompat等兼容类，其中实现了多个系统版本被代理对象，我们使用时只需要调用功能实现细节即可，而兼容类会自动根据我们系统版本，调用不同的版本对应的实现方法。
>
> 另一个使用场景就是缓存切换，我们抽象出通用的存取方法，而实际的缓存介质，我们可以根据需求进行切换。

#### 适配器模式

将两个原本相互独立，甚至是不相兼容的对象，通过适配器进行中间嵌合，让他们能够协调工作。

> 经典场景就是ListView和RecyclerView的Adapter。通过Adapter，可以将ListView 和 ItemView协调结合在一起。ListView和ItemView的具体实现是相互独立的，Adapter起的作用就是将两者协调到一起工作。

#### 组合模式

定义一个总的功能集合\(接口\)，以类似代理模式的方式，创建一个功能集合的实现子类，同样该子类只是作为一个代理对象使用，其中并没有具体的功能实现。对于功能集合的各项功能，我们将它们划分到不同的实现子类中。在某些场景下，我们需要用到其中的某项功能时，只需要创建对应的实现子类，注入到代理对象中。对于需要用到多项功能的情况，只需要注入多个实现子类即可。这样将功能灵活的拆分和组合能够实现功能代码的高度复用。

