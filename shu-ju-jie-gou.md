#### ArrayList

* 基于顺序存储解构，实际就是封装了对一个数组的操作；

* 因为是基于数组，其查找效率高；

* 同样也是因为基于数组，其增删效率较低，每增删一个元素，其后的元素需要相应的做出位置调整，而调整就需要进行数据的拷贝；

* 当数据量达到阀值时，需要进行一倍扩容，创建新的数组，将元素都拷贝进新的数组中；

#### 

#### LinkedList

* 线程不安全；
* 可以用来实现队列模型，其中提供了对应的从队列进行增删的API；
* 实现的数据解构是链表\(循环链表，双向链表\)，则增删的效率高；但是查找的效率低，因为它需要先定位到目标结点\(要拿到当前结点，必须先拿到它的前一个结点\)；
* 对查找是做了优化的，查找时会根据index先判断目标结点是位于链表的前半段还是后半段，然后才决定是进行顺序查询还是逆序查询；
* 在Android中，对LinkedList进行修改，实现了Queue接口，提供了对应的入队和出队方法，并且实现的数据解构是循环链表解构，通过一个空结点voidLink指向了队列的头结点和尾结点，形成了循环解构，并且能够快速的找到头尾结点；

#### HashMap

* HashMap是基于散列链表：数组+单链表
* HashMap中数据的存储方式是通过其中的table数组长度减1，在与要存储的数据的hash值进行逻辑与运算，计算出存储数据在table数组中的下标值。如果注意的是，这个下标下的数组元素可能已经存储了数据，并且两个数据的key相同，则会用新数据代替旧数据，否则**出现了Hash冲突**，存储数据被插入到对应下标的链表的头部；
* 什么是Hash冲突？

“无线对于有限，总是过多的。”因为HashMap中的table数组总归是容量有限的，无论Hash算法如何的高效，做到数据尽可能的散列，最终总是避免不了Hash冲突的情况。所谓的Hash冲突，就是不同的key，不同HashCode的数据，经过Hash算法的运算，最终得到了相同的数据\(下标\)。

* 如何避免Hash冲突？

Hash冲突是无法避免的，我们只能做到尽量的减少。

可以通过适当的扩容table数组和提高hash算法的效率两方面来减少Hash冲突；

* HashMap查询效率？

HashMap中实际上存在了两种数据存储解构，一种是数组，另一种是单链表；

在查询数据的效率上，数组要远大于单链表，所以要提高数据的查询效率，势必是通过提高数组的容量来实现。

当时数组的空间太大，势必会带来空间利用率的减低，空间太小，则出现Hash冲突的几率就增大了。为了解决这个问题，HashMap中设置了一个阀值\(负载因子\)，其默认值为0.75。

负载因子可以理解为空间的填满程度，当空间的填满程度达到阀值时，就开始为数组空间进行扩容，扩大为原来的两倍。

负载因子越大，数组填充的元素越多，空间利用率增加，但是相应的hash冲突的机会也增加。单个元素下挂载的链表的长度增加，HashMap的查询效率减低；相反，在负载因子越小时，在table数组还存在较多空间的时候，table数组就开始进行扩容，这种情况下，空间利用率低，但优点是hash冲突减少，查询数据的效率也提高了。

通过负载因子的这个特点，我们可以人为的修改负载因子的值。当内存较为紧张的机器上，可以适当的提高负载因子的值；而对于内存较为充裕的机器，我们可以适当的减小负载因子的值；

* 为什么HashMap是无序的？

* HashMap是如何做到让数据散列的分布到数组中？

1、每一个存储对象都能计算出独一无二的hash值；

> hash算法可以是任意的，目的只为计算出来的下标尽可能的散列。

2、确保table数组的长度一直是2的N次方；

> 在计算存储数据的下标时，采用的是数据的hash值与数组长度减1 进行逻辑与运算。因为数组的长度是2的N次方，减1后结果必为奇数。这样的好处在于计算结果必定不会超出数组的范围，并且结果为奇数或偶数的几率是相等的\(如果是偶数，与偶数进行逻辑与操作，结果必定为偶数\)，确保了数据是散列分布的。
>
> 相对于使用取模的方式来计算散列下标，逻辑与运算的效率要高的多。



























